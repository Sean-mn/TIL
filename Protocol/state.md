# Stateful과 Stateless
클라이언트와 서버간의 연결 상태를 관리하는 방식에 따라 구분되는 특성이다.

<br>

## 상태유지성 (Stateful)
**상태유지성 (Stateful)** 이란, **서버가 클라이언트의 상태를 기억하고 저장하는 구조**를 의미한다.

클라이언트의 요청을 처리할 때, 이전에 어떤 요청이 왔는지, <br>
어떤 상태였는지를 서버가 알고 있는 것이다.

**예시)**

```md
고객: 이 사과 얼마인가요?
점원: 2000원입니다.

고객: 2개 구매할게요.
점원: 총 4000원입니다.

고객: 카드로 구매할게요.
점원: 4000원 결제 완료되었습니다.
```
위 대화에서 점원은 고객이 했던 말들을 기억을 하고 있어야만 대화가 가능하다.

점원 쪽에서 고객이 카드로 구매하겠다는 말을 이해하려면, 이전의 사과를 2개 사겠다는 말을 기억해야한다. 즉, 점원은 고객의 **상태를 유지하고 있어야한다**는 말이다.

### Stateful의 장점

1. 유저의 로그인 상태, 게임 상태, 거래 진행 상황 등 복잡한 상태를 서버가 직접 관리할 수 있다
2. 클라이언트가 매번 모든 정보를 전송하지 않아도 된다.
3. 실시간 통신이 필요한 게임, 채팅 등에서는 상태 유지를 통해 더 나은 사용자 경험을 제공할 수 있다.

### Stateful의 단점

1. 상태가 특정 서버에 묶이기 때문에 스케일 아웃이 어렵다.
2. 서버가 꺼지면 상태 정보가 사라질 수 있어, 장애 복구가 어렵다.
3. 많은 사용자의 상태를 메모리에 저장하면 리소스가 많이 소모된다.

<br>

## 무상태성 (Stateless)
**무상태성 (Stateless)** 이란, 서버가 클라이언트의 상태 정보를 저장하지 않는 구조를 의미한다.

각 요청은 **독립적**이며, 서버는 이전의 요청이 어떤 내용이었는지 기억하지 못한다. <br>
따라서 매 요청마다 필요한 모든 정보를 함께 보내야한다.

**예시)**
```md
고객: 사과 2개 카드로 구매할게요.
점원: 총 4000원입니다. 결제 완료되었습니다.
```

위 대화에서 점원은 고객의 과거 요청을 기억하지 않아도 된다.
고객이 한 번에 필요한 모든 정보를 줬기 때문에, 점원은 즉시 응답할 수 있다.

즉, 서버는 클라이언트의 상태에 의존하지 않고,
요청마다 완전한 정보가 포함되어야 처리 가능한 방식이 **Stateless**이다.

### Stateless의 장점

1. 상태를 저장하지 않기 때문에 서버를 수평적으로 쉽게 확장할 수 있다.
2. 서버에 저장된 상태가 없기 때문에 장애 복구, 배포, 재시작 시 복잡한 상태 복원이 필요 없다.
3. 요청 자체만 처리하면 되므로 코드가 간단하고, 테스트나 디버깅이 용이하다.

### Stateless의 단점

1. 매 요청마다 인증 토큰, 상태 정보 등을 포함해야 하기 때문에 요청 크기가 커질 수 있다.
2. 여러 단계의 상호작용(예: 게임 상태, 트랜잭션 등)이 필요한 시스템에서는 불리하다.
3. 상태가 없기 때문에 요청 간 연관성을 고려한 처리가 필요하면 별도의 로직이나 외부 저장소가 필요하다.